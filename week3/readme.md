TODO: Reflect on what you learned this week and what is still unclear.

This weeks content was based on algorithms and how they are defined by their efficiency, parsimony and elegance.

**Khan academy algorithms course**

The Khan academy algorithms course went through the binary search algorithm which can quickly find a random number in a list of numbers quicker than just doing a linear search (searching one by one). The course then went through the different asymptotic notations which are used to categorise algorithms by their speed. The main notations covered were theta notation (algorithm speed bound from above and below), big O notation(algorithm speed bound only from above), and big omega notation (algorithm speed bound only from below). In my opinion, the most useful of all these notations is the big O notation, as we always want to try and improve the speed of algorithms from above rather than bound them from below and limit their speed. Although, theta notation allows algorithm speed and efficiency to be calculated with more precision by narrowing down the speed to a certain region.

**Week 3 exercises**

This weeks exercises focused on algorithms and the importance of process. That is, how a certain task is performed based on a series of steps. This week was interesting particularly in regards to how information can be processed and understood. 'pseudocode' defines the use of abstracted code which is arranged in a way which makes a process easier to understand due to the way people process information, whereas a computer needs incredibly specific steps in order to complete a task as it doesn't have the same intuition that people do. 

Technically, this week was about using 'while' statements to define recursion in a task. This came up in the not_number_rejector function and was useful in describing tasks which need to be repeated until the desirable outcome is produced. Because of this, I thought the most important concept for the week was managing flow control in order to complete a task. 

**"Algorithms to live by" podcast**

The algorithms to live by podcast goes over some algorithms which can be considered important in the decisions people make in their lives. The most reoccuring algorithm in the episode was the explore/exploit algorithm which relates to the amount of time we should spend exploring something and the amount of time we should spend exploiting it. The speakers referenced that the math says that 37% of the time should be spend researching something, with the rest of the time being spent reaping the rewards of said research. While this is a very optimal algorithm, what I thought was interesting is that it is only successful 37% of the time. This led to the discussion of algorithms and whether we should blame the result or the process for a given outcome. Another fitting topic was 'overfitting' which is where algorithms can actually become less efficient by the overuse of variables which cloud the judgement and focus of what the algorithm is actually trying to achieve. 

**Code reading experience**

The different ways to complete the loops_7() function from last week also have different levels of readability. Even though they all achieve the same outcome, each method has a different way of expressing the task. In general, I would assume that the shortest methods can often be the simplest, as they have found a way of compiling the problem into a structure which addresses the problem quickly. But I found that some of the longer solutions were actually easier to understand as they notated function and variables in a way which made their uses easier to understand. It's also interesting to see how some people solve the problem very mathematically using loops and technicalities, whereas some people solve the problem geometrically based on their intuition. However, I found that the more abstract the naming of variables and processes, the harder it was to follow and understand the process.